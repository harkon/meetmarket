/**
 * Module dependencies.
 */

var mongoose = require('mongoose');
var cloudinary = require('../../config/cloudinary');
var config = require('../../config/config');
var utils = require('../../lib/utils');
var Schema = mongoose.Schema;
var async = require('async');

/**
 * Getters
 */

var getCategory = function(tags) {
  return category.join(',');
};

/**
 * Setters
 */

var setCategory = function(tags) {
  return category.split(',');
};

/**
 * Product Schema
 */

var ProductSchema = new Schema({

  department: {
    type: String,
    default: ''
  },
  category: {
    type: String,
    default: ''
  },
  brand: {
    id: String,
    name: String,
    image: {}
  },
  name: {
    type: String,
    default: '',
    trim: true
  },
  sku: {
    type: String,
    default: ''
  },
  slug: {
    type: String,
    lowercase: true,
    trim: true,
    default: ''
  },
  desc: {
    type: String,
    default: '',
    trim: true
  },
  assets: {
    images: []
  },
  attrs: [], //Will be used to implement facetting
  shipping: {
    dimensions: {
      height: {
        type: Number,
        default: 0
      },
      length: {
        type: Number,
        default: 0
      },
      width: {
        type: Number,
        default: 0
      }
    },
    weight: {
      type: Number,
      default: 0
    }
  },
  lastModified: {
    type: Date,
    default: Date.now
  },
  // foreign keys
  _shop: {
    type: Schema.ObjectId,
    ref: 'Shop'
  },
  _variants: {
    type: Schema.ObjectId,
    ref: 'Variant'
  },
  _categories: [{
    type: Schema.ObjectId,
    ref: 'Category'
  }]

});

/**
 * Validations
 */

ProductSchema.path('name').required(true, 'Item name cannot be blank');
ProductSchema.path('sku').required(true, 'Item SKU cannot be blank');

/**
 * Pre-save hook
 */

ProductSchema.pre('save', function(next) {

  var self = this;
  var calls = [];

  self.category = self._categories.join('/');

  self._categories.forEach(function(id) {

    calls.push(function(callback) {
      mongoose.models["Category"].findOne({
        _id: id
      }, function(err, category) {
        if (err) return callback(err);
        callback(null, category)
      });
    });

  });

  async.parallel(calls, function(err, result) {
    /* this code will run after all calls finished the job or
       when any of the calls passes an error */
    if (err) return next(err);
    result.forEach(function(category) {
      if (category.parentId === null) self.department = category.name;
    })
    next(null, result)
  });


});

/**
 * Methods
 */

ProductSchema.methods = {

  /**
   * Save article and upload image
   *
   * @param {Object} images
   * @param {Function} cb
   * @api private
   */

  uploadAndSave: function(image, cb) {
    console.log("\nimage", image)
    if (!image) return this.save(cb);

    var self = this;
    this.validate(function(err) {

      if (err) return cb(err);
      // File upload (for promise api)
      cloudinary.uploader.upload(__dirname + image.path, {
        type: "upload"
      })
        .then(function(img) {
          console.log();
          console.log("** File Upload (Promise)");
          console.log("* public_id for the uploaded image is generated by Cloudinary's service.");
          console.log("* " + img.public_id);
          console.log("**")
          self.assets.images.push(img);
          return self.save(cb);
        })
        .catch(function(err) {
          console.log();
          console.log("** File Upload (Promise)");
          if (err) {
            console.warn(err);
          }
        })
    });
  },

  /**
   * Add comment
   *
   * @param {User} user
   * @param {Object} comment
   * @param {Function} cb
   * @api private
   */

  // addComment: function(user, comment, cb) {
  //   var notify = require('../mailer');

  //   this.comments.push({
  //     body: comment.body,
  //     user: user._id
  //   });

  //   if (!this.user.email) this.user.email = 'email@product.com';
  //   notify.comment({
  //     article: this,
  //     currentUser: user,
  //     comment: comment.body
  //   });

  //   this.save(cb);
  // },

  /**
   * Remove comment
   *
   * @param {commentId} String
   * @param {Function} cb
   * @api private
   */

  // removeComment: function(commentId, cb) {
  //   var index = utils.indexof(this.comments, {
  //     id: commentId
  //   });
  //   if (~index) this.comments.splice(index, 1);
  //   else return cb('not found');
  //   this.save(cb);
  // }
}

/**
 * Statics
 */

ProductSchema.statics = {

  /**
   * Find article by id
   *
   * @param {ObjectId} id
   * @param {Function} cb
   * @api private
   */

  load: function(id, cb) {
    this.findOne({
      _id: id
    })
      .populate('_shop')
      .populate('_categories', 'name')
      .exec(cb);
  },

  /**
   * List articles
   *
   * @param {Object} options
   * @param {Function} cb
   * @api private
   */

  list: function(options, cb) {
    var criteria = options.criteria || {}

    this.find(criteria)
      .populate('_shop')
      .populate('_categories', 'name')
      .sort({
        'sku': -1
      }) // sort by SKU
    .limit(options.perPage)
      .skip(options.perPage * options.page)
      .exec(cb);
  }
}

mongoose.model('Product', ProductSchema);